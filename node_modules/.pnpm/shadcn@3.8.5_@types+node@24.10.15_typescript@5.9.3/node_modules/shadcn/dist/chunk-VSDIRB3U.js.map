{"version":3,"sources":["../src/utils/transformers/transform-icons.ts","../src/utils/transformers/transform-css-vars.ts","../src/utils/transformers/transform-rtl.ts","../src/utils/transformers/transform-menu.ts"],"names":["transformIcons","sourceFile","config","iconLibrary","iconLibraries","targetLibrary","libraryConfig","transformedIcons","element","SyntaxKind","libraryPropAttr","attr","jsxIconAttr","targetIconName","usageMatch","jsxAttr","componentName","defaultPropsStr","userAttributes","existingPropNames","defaultPropsToAdd","prop","propName","allProps","importDeclaration","iconPlaceholderImport","specifier","importStatements","addedImports","importStmt","importMatch","importedNames","modulePath","namedImports","name","icon","newImport","_useSemicolon","importDecl","transformCssVars","baseColor","node","raw","mapped","applyColorMapping","splitClassName","className","lastColonIndex","bracketDepth","i","char","variant","nameWithAlpha","slashIndex","alpha","PREFIXES","input","mapping","classNames","lightMode","darkMode","value","modifier","prefix","needle","RTL_MAPPINGS","RTL_TRANSLATE_X_MAPPINGS","RTL_REVERSE_MAPPINGS","RTL_SWAP_MAPPINGS","RTL_LOGICAL_SIDE_SLIDE_MAPPINGS","RTL_FLIP_MARKER","RTL_SIDE_PROP_COMPONENTS","RTL_SIDE_PROP_MAPPINGS","POSITIONING_PREFIXES","transformRtl","applyRtlTransformToSourceFile","transformDirection","source","rtl","Project","ScriptKind","stripQuotes","str","transformStringLiteralNode","text","applyRtlMapping","physical","rtlPhysical","rtlValue","rtlClass","reverseClass","swapped","variantPattern","logical","mappedValue","isPhysicalSideVariant","p","result","firstArg","initializer","callExpression","arg","propInit","classNameProp","init","tagName","sideAttr","sideValue","currentValue","functionName","transformMenu","replacement","newText"],"mappings":"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","file":"chunk-VSDIRB3U.js","sourcesContent":["import { iconLibraries, type IconLibraryName } from \"@/src/icons/libraries\"\nimport { Transformer } from \"@/src/utils/transformers\"\nimport { SourceFile, SyntaxKind } from \"ts-morph\"\n\nexport const transformIcons: Transformer = async ({ sourceFile, config }) => {\n  const iconLibrary = config.iconLibrary\n\n  // Fail silently if the icon library is not supported.\n  // This is for legacy icon libraries.\n  if (!iconLibrary || !(iconLibrary in iconLibraries)) {\n    return sourceFile\n  }\n\n  const targetLibrary = iconLibrary as IconLibraryName\n  const libraryConfig = iconLibraries[targetLibrary]\n  let transformedIcons: string[] = []\n\n  for (const element of sourceFile.getDescendantsOfKind(\n    SyntaxKind.JsxSelfClosingElement\n  )) {\n    if (element.getTagNameNode()?.getText() !== \"IconPlaceholder\") {\n      continue\n    }\n\n    // Find the library-specific prop (e.g., \"lucide\", \"tabler\", \"hugeicons\")\n    const libraryPropAttr = element.getAttributes().find((attr) => {\n      if (attr.getKind() !== SyntaxKind.JsxAttribute) {\n        return false\n      }\n      const jsxAttr = attr.asKindOrThrow(SyntaxKind.JsxAttribute)\n      return jsxAttr.getNameNode().getText() === targetLibrary\n    })\n\n    if (!libraryPropAttr) {\n      continue // No icon specified for this library\n    }\n\n    const jsxIconAttr = libraryPropAttr.asKindOrThrow(SyntaxKind.JsxAttribute)\n    const targetIconName = jsxIconAttr\n      .getInitializer()\n      ?.getText()\n      .replace(/^[\"']|[\"']$/g, \"\")\n\n    if (!targetIconName) {\n      continue\n    }\n\n    if (!transformedIcons.includes(targetIconName)) {\n      transformedIcons.push(targetIconName)\n    }\n\n    const usage = libraryConfig.usage\n    const usageMatch = usage.match(/<(\\w+)([^>]*)\\s*\\/>/)\n\n    // Remove the library-specific prop\n    jsxIconAttr.remove()\n\n    // Remove all other library-specific props\n    for (const attr of element.getAttributes()) {\n      if (attr.getKind() !== SyntaxKind.JsxAttribute) {\n        continue\n      }\n      const jsxAttr = attr.asKindOrThrow(SyntaxKind.JsxAttribute)\n      const attrName = jsxAttr.getNameNode().getText()\n      // Filter out library-specific props (lucide, tabler, hugeicons, etc.)\n      if (attrName in iconLibraries) {\n        jsxAttr.remove()\n      }\n    }\n\n    if (!usageMatch) {\n      element.getTagNameNode()?.replaceWithText(targetIconName)\n      continue\n    }\n\n    const [, componentName, defaultPropsStr] = usageMatch\n\n    if (componentName === \"ICON\") {\n      // Get remaining user attributes (non-library props)\n      const userAttributes = element\n        .getAttributes()\n        .filter((attr) => {\n          if (attr.getKind() !== SyntaxKind.JsxAttribute) {\n            return true\n          }\n          const jsxAttr = attr.asKindOrThrow(SyntaxKind.JsxAttribute)\n          const attrName = jsxAttr.getNameNode().getText()\n          // Filter out library-specific props (lucide, tabler, hugeicons, etc.)\n          return !(attrName in iconLibraries)\n        })\n        .map((attr) => attr.getText())\n        .join(\" \")\n\n      if (userAttributes.trim()) {\n        element.replaceWithText(`<${targetIconName} ${userAttributes} />`)\n      } else {\n        element.getTagNameNode()?.replaceWithText(targetIconName)\n      }\n    } else {\n      const existingPropNames = new Set(\n        element\n          .getAttributes()\n          .filter((attr) => attr.getKind() === SyntaxKind.JsxAttribute)\n          .map((attr) =>\n            attr.asKindOrThrow(SyntaxKind.JsxAttribute).getNameNode().getText()\n          )\n      )\n\n      // Replace ICON placeholder in defaultPropsStr with actual icon name\n      const defaultPropsWithIcon = defaultPropsStr.replace(\n        /\\{ICON\\}/g,\n        `{${targetIconName}}`\n      )\n\n      const defaultPropsToAdd = defaultPropsWithIcon\n        .trim()\n        .split(/\\s+(?=\\w+=)/)\n        .filter((prop) => prop)\n        .map((prop) => {\n          const propName = prop.split(\"=\")[0]\n          return propName && !existingPropNames.has(propName) ? prop : null\n        })\n        .filter(Boolean)\n\n      const userAttributes = element\n        .getAttributes()\n        .filter((attr) => {\n          if (attr.getKind() !== SyntaxKind.JsxAttribute) {\n            return true\n          }\n          const jsxAttr = attr.asKindOrThrow(SyntaxKind.JsxAttribute)\n          const attrName = jsxAttr.getNameNode().getText()\n          // Filter out library-specific props (lucide, tabler, hugeicons, etc.)\n          return !(attrName in iconLibraries)\n        })\n        .map((attr) => attr.getText())\n        .join(\" \")\n\n      const allProps = [...defaultPropsToAdd, userAttributes]\n        .filter(Boolean)\n        .join(\" \")\n\n      element.replaceWithText(`<${componentName} ${allProps} />`)\n    }\n  }\n\n  for (const importDeclaration of sourceFile.getImportDeclarations() ?? []) {\n    const moduleSpecifier = importDeclaration.getModuleSpecifier()?.getText()\n    if (moduleSpecifier?.includes(\"icon-placeholder\")) {\n      const namedImports = importDeclaration.getNamedImports() ?? []\n      const iconPlaceholderImport = namedImports.find(\n        (specifier) => specifier.getName() === \"IconPlaceholder\"\n      )\n\n      if (iconPlaceholderImport) {\n        iconPlaceholderImport.remove()\n      }\n\n      if (importDeclaration.getNamedImports()?.length === 0) {\n        importDeclaration.remove()\n      }\n    }\n  }\n\n  if (transformedIcons.length > 0) {\n    const importStatements = libraryConfig.import.split(\"\\n\")\n    const addedImports = []\n\n    for (const importStmt of importStatements) {\n      const importMatch = importStmt.match(\n        /import\\s+{([^}]+)}\\s+from\\s+['\"]([^'\"]+)['\"]/\n      )\n\n      if (!importMatch) continue\n\n      const [, importedNames, modulePath] = importMatch\n      const namedImports = importedNames\n        .split(\",\")\n        .map((name) => name.trim())\n        .map((name) => {\n          if (name === \"ICON\") {\n            return transformedIcons.map((icon) => ({ name: icon }))\n          }\n          return { name }\n        })\n        .flat()\n\n      const newImport = sourceFile.addImportDeclaration({\n        moduleSpecifier: modulePath,\n        namedImports,\n      })\n\n      addedImports.push(newImport)\n    }\n\n    if (!_useSemicolon(sourceFile)) {\n      for (const importDecl of addedImports) {\n        importDecl.replaceWithText(importDecl.getText().replace(\";\", \"\"))\n      }\n    }\n  }\n\n  return sourceFile\n}\n\nfunction _useSemicolon(sourceFile: SourceFile) {\n  return (\n    sourceFile.getImportDeclarations()?.[0]?.getText().endsWith(\";\") ?? false\n  )\n}\n","import { registryBaseColorSchema } from \"@/src/schema\"\nimport { Transformer } from \"@/src/utils/transformers\"\nimport { ScriptKind, SyntaxKind } from \"ts-morph\"\nimport { z } from \"zod\"\n\nexport const transformCssVars: Transformer = async ({\n  sourceFile,\n  config,\n  baseColor,\n}) => {\n  // No transform if using css variables.\n  if (config.tailwind?.cssVariables || !baseColor?.inlineColors) {\n    return sourceFile\n  }\n\n  // Find jsx attributes with the name className.\n  // const openingElements = sourceFile.getDescendantsOfKind(SyntaxKind.JsxElement)\n  // console.log(openingElements)\n  // const jsxAttributes = sourceFile\n  //   .getDescendantsOfKind(SyntaxKind.JsxAttribute)\n  //   .filter((node) => node.getName() === \"className\")\n\n  // for (const jsxAttribute of jsxAttributes) {\n  //   const value = jsxAttribute.getInitializer()?.getText()\n  //   if (value) {\n  //     const valueWithColorMapping = applyColorMapping(\n  //       value.replace(/\"/g, \"\"),\n  //       baseColor.inlineColors\n  //     )\n  //     jsxAttribute.setInitializer(`\"${valueWithColorMapping}\"`)\n  //   }\n  // }\n  sourceFile.getDescendantsOfKind(SyntaxKind.StringLiteral).forEach((node) => {\n    const raw = node.getLiteralText()\n    const mapped = applyColorMapping(raw, baseColor.inlineColors).trim()\n    if (mapped !== raw) {\n      node.setLiteralValue(mapped)\n    }\n  })\n\n  return sourceFile\n}\n\n// export default function transformer(file: FileInfo, api: API) {\n//   const j = api.jscodeshift.withParser(\"tsx\")\n\n//   // Replace bg-background with \"bg-white dark:bg-slate-950\"\n//   const $j = j(file.source)\n//   return $j\n//     .find(j.JSXAttribute, {\n//       name: {\n//         name: \"className\",\n//       },\n//     })\n//     .forEach((path) => {\n//       const { node } = path\n//       if (node?.value?.type) {\n//         if (node.value.type === \"StringLiteral\") {\n//           node.value.value = applyColorMapping(node.value.value)\n//           console.log(node.value.value)\n//         }\n\n//         if (\n//           node.value.type === \"JSXExpressionContainer\" &&\n//           node.value.expression.type === \"CallExpression\"\n//         ) {\n//           const callee = node.value.expression.callee\n//           if (callee.type === \"Identifier\" && callee.name === \"cn\") {\n//             node.value.expression.arguments.forEach((arg) => {\n//               if (arg.type === \"StringLiteral\") {\n//                 arg.value = applyColorMapping(arg.value)\n//               }\n\n//               if (\n//                 arg.type === \"LogicalExpression\" &&\n//                 arg.right.type === \"StringLiteral\"\n//               ) {\n//                 arg.right.value = applyColorMapping(arg.right.value)\n//               }\n//             })\n//           }\n//         }\n//       }\n//     })\n//     .toSource()\n// }\n\n// // export function splitClassName(input: string): (string | null)[] {\n// //   const parts = input.split(\":\")\n// //   const classNames = parts.map((part) => {\n// //     const match = part.match(/^\\[?(.+)\\]$/)\n// //     if (match) {\n// //       return match[1]\n// //     } else {\n// //       return null\n// //     }\n// //   })\n\n// //   return classNames\n// // }\n\n// Splits a className into [variant, name, alpha].\n// eg. hover:bg-primary-100 -> [hover, bg-primary, 100]\n// eg. sm:group-data-[size=default]/alert-dialog-content:text-left -> [sm:group-data-[size=default]/alert-dialog-content, text-left, null]\nexport function splitClassName(className: string): (string | null)[] {\n  if (!className.includes(\"/\") && !className.includes(\":\")) {\n    return [null, className, null]\n  }\n\n  // Find the last colon that's not inside brackets to split variant from name.\n  let lastColonIndex = -1\n  let bracketDepth = 0\n  for (let i = className.length - 1; i >= 0; i--) {\n    const char = className[i]\n    if (char === \"]\") bracketDepth++\n    else if (char === \"[\") bracketDepth--\n    else if (char === \":\" && bracketDepth === 0) {\n      lastColonIndex = i\n      break\n    }\n  }\n\n  let variant: string | null = null\n  let nameWithAlpha: string\n\n  if (lastColonIndex === -1) {\n    // No colon outside brackets, entire string is the name (possibly with alpha).\n    nameWithAlpha = className\n  } else {\n    variant = className.slice(0, lastColonIndex)\n    nameWithAlpha = className.slice(lastColonIndex + 1)\n  }\n\n  // Now split nameWithAlpha by \"/\" for alpha modifier.\n  // Alpha modifiers are numeric (e.g., /50) or arbitrary (e.g., /[50%]).\n  // Named groups like /alert-dialog-content would have been part of variant.\n  const slashIndex = nameWithAlpha.lastIndexOf(\"/\")\n  if (slashIndex === -1) {\n    return [variant, nameWithAlpha, null]\n  }\n\n  const name = nameWithAlpha.slice(0, slashIndex)\n  const alpha = nameWithAlpha.slice(slashIndex + 1)\n\n  return [variant, name, alpha]\n}\n\nconst PREFIXES = [\"bg-\", \"text-\", \"border-\", \"ring-offset-\", \"ring-\"]\n\nexport function applyColorMapping(\n  input: string,\n  mapping: z.infer<typeof registryBaseColorSchema>[\"inlineColors\"]\n) {\n  // Handle border classes.\n  if (input.includes(\" border \")) {\n    input = input.replace(\" border \", \" border border-border \")\n  }\n\n  // Build color mappings.\n  const classNames = input.split(\" \")\n  const lightMode = new Set<string>()\n  const darkMode = new Set<string>()\n  for (let className of classNames) {\n    const [variant, value, modifier] = splitClassName(className)\n    const prefix = PREFIXES.find((prefix) => value?.startsWith(prefix))\n    if (!prefix) {\n      if (!lightMode.has(className)) {\n        lightMode.add(className)\n      }\n      continue\n    }\n\n    const needle = value?.replace(prefix, \"\")\n    if (needle && needle in mapping.light) {\n      lightMode.add(\n        [variant, `${prefix}${mapping.light[needle]}`]\n          .filter(Boolean)\n          .join(\":\") + (modifier ? `/${modifier}` : \"\")\n      )\n\n      darkMode.add(\n        [\"dark\", variant, `${prefix}${mapping.dark[needle]}`]\n          .filter(Boolean)\n          .join(\":\") + (modifier ? `/${modifier}` : \"\")\n      )\n      continue\n    }\n\n    if (!lightMode.has(className)) {\n      lightMode.add(className)\n    }\n  }\n\n  return [...Array.from(lightMode), ...Array.from(darkMode)].join(\" \").trim()\n}\n","import { Transformer } from \"@/src/utils/transformers\"\nimport { Project, ScriptKind, SourceFile, SyntaxKind } from \"ts-morph\"\n\nimport { splitClassName } from \"./transform-css-vars\"\n\n// Physical → logical Tailwind class mappings (direct replacement).\n// Order matters to avoid partial matches:\n// - Negative prefixes before positive (e.g., -ml- before ml-).\n// - Specific corners before general ones e.g. rounded-tl- before rounded-l-.\n// - With-value variants before without-value (e.g., border-l- before border-l).\nconst RTL_MAPPINGS: [string, string][] = [\n  [\"-ml-\", \"-ms-\"],\n  [\"-mr-\", \"-me-\"],\n  [\"ml-\", \"ms-\"],\n  [\"mr-\", \"me-\"],\n  [\"pl-\", \"ps-\"],\n  [\"pr-\", \"pe-\"],\n  [\"-left-\", \"-start-\"],\n  [\"-right-\", \"-end-\"],\n  [\"left-\", \"start-\"],\n  [\"right-\", \"end-\"],\n  [\"inset-l-\", \"inset-inline-start-\"],\n  [\"inset-r-\", \"inset-inline-end-\"],\n  [\"rounded-tl-\", \"rounded-ss-\"],\n  [\"rounded-tr-\", \"rounded-se-\"],\n  [\"rounded-bl-\", \"rounded-es-\"],\n  [\"rounded-br-\", \"rounded-ee-\"],\n  [\"rounded-l-\", \"rounded-s-\"],\n  [\"rounded-r-\", \"rounded-e-\"],\n  [\"border-l-\", \"border-s-\"],\n  [\"border-r-\", \"border-e-\"],\n  [\"border-l\", \"border-s\"],\n  [\"border-r\", \"border-e\"],\n  [\"text-left\", \"text-start\"],\n  [\"text-right\", \"text-end\"],\n  [\"scroll-ml-\", \"scroll-ms-\"],\n  [\"scroll-mr-\", \"scroll-me-\"],\n  [\"scroll-pl-\", \"scroll-ps-\"],\n  [\"scroll-pr-\", \"scroll-pe-\"],\n  [\"float-left\", \"float-start\"],\n  [\"float-right\", \"float-end\"],\n  [\"clear-left\", \"clear-start\"],\n  [\"clear-right\", \"clear-end\"],\n  [\"origin-top-left\", \"origin-top-start\"],\n  [\"origin-top-right\", \"origin-top-end\"],\n  [\"origin-bottom-left\", \"origin-bottom-start\"],\n  [\"origin-bottom-right\", \"origin-bottom-end\"],\n  [\"origin-left\", \"origin-start\"],\n  [\"origin-right\", \"origin-end\"],\n]\n\n// Translate-x: adds rtl: variant (negative ↔ positive).\nconst RTL_TRANSLATE_X_MAPPINGS: [string, string][] = [\n  [\"-translate-x-\", \"translate-x-\"],\n  [\"translate-x-\", \"-translate-x-\"],\n]\n\n// Classes that need rtl:*-reverse (no logical equivalents).\nconst RTL_REVERSE_MAPPINGS: [string, string][] = [\n  [\"space-x-\", \"space-x-reverse\"],\n  [\"divide-x-\", \"divide-x-reverse\"],\n]\n\n// Classes that need rtl: variant with swapped value.\nconst RTL_SWAP_MAPPINGS: [string, string][] = [\n  [\"cursor-w-resize\", \"cursor-e-resize\"],\n  [\"cursor-e-resize\", \"cursor-w-resize\"],\n]\n\n// Slide animations inside logical side variants: [variant, physical, logical].\nconst RTL_LOGICAL_SIDE_SLIDE_MAPPINGS: [string, string, string][] = [\n  [\"data-[side=inline-start]\", \"slide-in-from-right\", \"slide-in-from-end\"],\n  [\"data-[side=inline-start]\", \"slide-out-to-right\", \"slide-out-to-end\"],\n  [\"data-[side=inline-end]\", \"slide-in-from-left\", \"slide-in-from-start\"],\n  [\"data-[side=inline-end]\", \"slide-out-to-left\", \"slide-out-to-start\"],\n]\n\n// Marker class for icons that should get rtl:rotate-180.\nconst RTL_FLIP_MARKER = \"cn-rtl-flip\"\n\n// Components with side prop transformed to logical values.\nconst RTL_SIDE_PROP_COMPONENTS = [\n  \"ContextMenuContent\",\n  \"ContextMenuSubContent\",\n  \"DropdownMenuSubContent\",\n]\n\n// Side prop value mappings.\nconst RTL_SIDE_PROP_MAPPINGS: Record<string, string> = {\n  right: \"inline-end\",\n  left: \"inline-start\",\n}\n\n// Positioning prefixes to skip for physical side variants.\nconst POSITIONING_PREFIXES = [\"-left-\", \"-right-\", \"left-\", \"right-\"]\n\nexport const transformRtl: Transformer = async ({ sourceFile, config }) => {\n  if (!config.rtl) {\n    return sourceFile\n  }\n\n  applyRtlTransformToSourceFile(sourceFile)\n\n  return sourceFile\n}\n\n// Standalone function to transform source code for RTL.\n// This is used by the build script.\nexport async function transformDirection(source: string, rtl: boolean) {\n  if (!rtl) {\n    return source\n  }\n\n  const project = new Project({\n    useInMemoryFileSystem: true,\n  })\n\n  const sourceFile = project.createSourceFile(\"component.tsx\", source, {\n    scriptKind: ScriptKind.TSX,\n    overwrite: true,\n  })\n\n  applyRtlTransformToSourceFile(sourceFile)\n\n  return sourceFile.getText()\n}\n\nfunction stripQuotes(str: string) {\n  return str.replace(/^[\"']|[\"']$/g, \"\")\n}\n\n// Transforms a string literal node by applying RTL mappings.\nfunction transformStringLiteralNode(node: {\n  getText(): string\n  replaceWithText(text: string): void\n}) {\n  const text = stripQuotes(node.getText() ?? \"\")\n  node.replaceWithText(`\"${applyRtlMapping(text)}\"`)\n}\n\nexport function applyRtlMapping(input: string) {\n  return input\n    .split(\" \")\n    .flatMap((className) => {\n      // Skip classes that already have rtl: or ltr: prefix.\n      if (className.startsWith(\"rtl:\") || className.startsWith(\"ltr:\")) {\n        return [className]\n      }\n\n      // Replace the cn-rtl-flip marker with rtl:rotate-180.\n      if (className === RTL_FLIP_MARKER) {\n        return [\"rtl:rotate-180\"]\n      }\n      const [variant, value, modifier] = splitClassName(className)\n\n      if (!value) {\n        return [className]\n      }\n\n      // Check for translate-x patterns first (add rtl: variant, don't replace).\n      for (const [physical, rtlPhysical] of RTL_TRANSLATE_X_MAPPINGS) {\n        if (value.startsWith(physical)) {\n          const rtlValue = value.replace(physical, rtlPhysical)\n          const rtlClass = variant\n            ? `rtl:${variant}:${rtlValue}${modifier ? `/${modifier}` : \"\"}`\n            : `rtl:${rtlValue}${modifier ? `/${modifier}` : \"\"}`\n          return [className, rtlClass]\n        }\n      }\n\n      // Check for space-x/divide-x patterns (add rtl:*-reverse variant).\n      for (const [prefix, reverseClass] of RTL_REVERSE_MAPPINGS) {\n        if (value.startsWith(prefix)) {\n          const rtlClass = variant\n            ? `rtl:${variant}:${reverseClass}`\n            : `rtl:${reverseClass}`\n          return [className, rtlClass]\n        }\n      }\n\n      // Check for cursor and other swap patterns (add rtl: variant with swapped value).\n      for (const [physical, swapped] of RTL_SWAP_MAPPINGS) {\n        if (value === physical) {\n          const rtlClass = variant\n            ? `rtl:${variant}:${swapped}`\n            : `rtl:${swapped}`\n          return [className, rtlClass]\n        }\n      }\n\n      // Check for slide animations inside logical side variants.\n      // e.g., data-[side=inline-start]:slide-in-from-right-2 → data-[side=inline-start]:slide-in-from-end-2\n      for (const [\n        variantPattern,\n        physical,\n        logical,\n      ] of RTL_LOGICAL_SIDE_SLIDE_MAPPINGS) {\n        if (variant?.includes(variantPattern) && value.startsWith(physical)) {\n          const mappedValue = value.replace(physical, logical)\n          const result = modifier\n            ? `${variant}:${mappedValue}/${modifier}`\n            : `${variant}:${mappedValue}`\n          return [result]\n        }\n      }\n\n      // Skip positioning transformations for physical side variants.\n      // e.g., data-[side=left]:-right-1 should NOT become data-[side=left]:-end-1.\n      const isPhysicalSideVariant =\n        variant?.includes(\"data-[side=left]\") ||\n        variant?.includes(\"data-[side=right]\")\n\n      // Find matching RTL mapping for direct replacement.\n      let mappedValue = value\n      for (const [physical, logical] of RTL_MAPPINGS) {\n        if (\n          isPhysicalSideVariant &&\n          POSITIONING_PREFIXES.some((p) => physical.startsWith(p))\n        ) {\n          continue\n        }\n\n        if (value.startsWith(physical)) {\n          // For patterns without trailing '-', require exact match to avoid\n          // partial matches like border-ring matching border-r.\n          if (!physical.endsWith(\"-\") && value !== physical) {\n            continue\n          }\n          mappedValue = value.replace(physical, logical)\n          break\n        }\n      }\n\n      // Reassemble with variant and modifier.\n      let result: string\n      if (variant) {\n        result = modifier\n          ? `${variant}:${mappedValue}/${modifier}`\n          : `${variant}:${mappedValue}`\n      } else {\n        result = modifier ? `${mappedValue}/${modifier}` : mappedValue\n      }\n\n      return [result]\n    })\n    .join(\" \")\n}\n\n// Core RTL transformation logic that operates on a SourceFile.\n// Extracted to be reusable by both transformRtl (CLI) and transformDirection (build script).\nfunction applyRtlTransformToSourceFile(sourceFile: SourceFile) {\n  // Find the cva function calls.\n  sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .filter((node) => node.getExpression().getText() === \"cva\")\n    .forEach((node) => {\n      // cva(base, ...).\n      const firstArg = node.getArguments()[0]\n      if (firstArg?.isKind(SyntaxKind.StringLiteral)) {\n        transformStringLiteralNode(firstArg)\n      }\n\n      // cva(..., { variants: { ... } }).\n      if (node.getArguments()[1]?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n        node\n          .getArguments()[1]\n          ?.getDescendantsOfKind(SyntaxKind.PropertyAssignment)\n          .find((node) => node.getName() === \"variants\")\n          ?.getDescendantsOfKind(SyntaxKind.PropertyAssignment)\n          .forEach((node) => {\n            node\n              .getDescendantsOfKind(SyntaxKind.PropertyAssignment)\n              .forEach((prop) => {\n                const classNames = prop.getInitializerIfKind(\n                  SyntaxKind.StringLiteral\n                )\n                if (classNames) {\n                  transformStringLiteralNode(classNames)\n                }\n              })\n          })\n      }\n    })\n\n  // Find all jsx attributes with the name className.\n  sourceFile.getDescendantsOfKind(SyntaxKind.JsxAttribute).forEach((node) => {\n    if (node.getNameNode().getText() === \"className\") {\n      // className=\"...\".\n      const initializer = node.getInitializer()\n      if (initializer?.isKind(SyntaxKind.StringLiteral)) {\n        transformStringLiteralNode(initializer)\n      }\n\n      // className={...}.\n      if (node.getInitializer()?.isKind(SyntaxKind.JsxExpression)) {\n        // Check if it's a call to cn().\n        const callExpression = node\n          .getInitializer()\n          ?.getDescendantsOfKind(SyntaxKind.CallExpression)\n          .find((node) => node.getExpression().getText() === \"cn\")\n        if (callExpression) {\n          callExpression.getArguments().forEach((arg) => {\n            if (\n              arg.isKind(SyntaxKind.ConditionalExpression) ||\n              arg.isKind(SyntaxKind.BinaryExpression)\n            ) {\n              arg\n                .getChildrenOfKind(SyntaxKind.StringLiteral)\n                .forEach(transformStringLiteralNode)\n            }\n            if (arg.isKind(SyntaxKind.StringLiteral)) {\n              transformStringLiteralNode(arg)\n            }\n          })\n        }\n      }\n    }\n\n    // classNames={...}.\n    if (node.getNameNode().getText() === \"classNames\") {\n      if (node.getInitializer()?.isKind(SyntaxKind.JsxExpression)) {\n        node\n          .getDescendantsOfKind(SyntaxKind.PropertyAssignment)\n          .forEach((node) => {\n            if (node.getInitializer()?.isKind(SyntaxKind.CallExpression)) {\n              const callExpression = node.getInitializerIfKind(\n                SyntaxKind.CallExpression\n              )\n              if (callExpression) {\n                callExpression.getArguments().forEach((arg) => {\n                  if (arg.isKind(SyntaxKind.ConditionalExpression)) {\n                    arg\n                      .getChildrenOfKind(SyntaxKind.StringLiteral)\n                      .forEach(transformStringLiteralNode)\n                  }\n                  if (arg.isKind(SyntaxKind.StringLiteral)) {\n                    transformStringLiteralNode(arg)\n                  }\n                })\n              }\n            }\n\n            const propInit = node.getInitializer()\n            if (propInit?.isKind(SyntaxKind.StringLiteral)) {\n              if (node.getNameNode().getText() !== \"variant\") {\n                transformStringLiteralNode(propInit)\n              }\n            }\n          })\n      }\n    }\n  })\n\n  // Find mergeProps calls with className property containing cn().\n  sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .filter((node) => node.getExpression().getText() === \"mergeProps\")\n    .forEach((node) => {\n      const firstArg = node.getArguments()[0]\n      if (firstArg?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n        // Find className property.\n        const classNameProp = firstArg\n          .getProperties()\n          .find(\n            (prop) =>\n              prop.isKind(SyntaxKind.PropertyAssignment) &&\n              prop.getName() === \"className\"\n          )\n        if (classNameProp?.isKind(SyntaxKind.PropertyAssignment)) {\n          const init = classNameProp.getInitializer()\n          // Handle cn() call.\n          if (init?.isKind(SyntaxKind.CallExpression)) {\n            if (init.getExpression().getText() === \"cn\") {\n              init.getArguments().forEach((arg) => {\n                if (arg.isKind(SyntaxKind.StringLiteral)) {\n                  transformStringLiteralNode(arg)\n                }\n                if (\n                  arg.isKind(SyntaxKind.ConditionalExpression) ||\n                  arg.isKind(SyntaxKind.BinaryExpression)\n                ) {\n                  arg\n                    .getChildrenOfKind(SyntaxKind.StringLiteral)\n                    .forEach(transformStringLiteralNode)\n                }\n              })\n            }\n          }\n          // Handle plain string literal.\n          if (init?.isKind(SyntaxKind.StringLiteral)) {\n            transformStringLiteralNode(init)\n          }\n        }\n      }\n    })\n\n  // Transform side prop to logical values for specific components.\n  ;[\n    ...sourceFile.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement),\n    ...sourceFile.getDescendantsOfKind(SyntaxKind.JsxOpeningElement),\n  ].forEach((element) => {\n    const tagName = element.getTagNameNode().getText()\n    if (!RTL_SIDE_PROP_COMPONENTS.includes(tagName)) {\n      return\n    }\n\n    const sideAttr = element\n      .getAttributes()\n      .find(\n        (attr) =>\n          attr.isKind(SyntaxKind.JsxAttribute) &&\n          attr.getNameNode().getText() === \"side\"\n      )\n\n    if (!sideAttr?.isKind(SyntaxKind.JsxAttribute)) {\n      return\n    }\n\n    const sideValue = sideAttr.getInitializer()\n    if (!sideValue?.isKind(SyntaxKind.StringLiteral)) {\n      return\n    }\n\n    const currentValue = stripQuotes(sideValue.getText() ?? \"\")\n    const mappedValue = RTL_SIDE_PROP_MAPPINGS[currentValue]\n    if (mappedValue) {\n      sideValue.replaceWithText(`\"${mappedValue}\"`)\n    }\n  })\n\n  // Transform default parameter values for side prop (e.g., side = \"right\").\n  // Only for functions whose names are in the whitelist.\n  sourceFile.getDescendantsOfKind(SyntaxKind.BindingElement).forEach((node) => {\n    const paramName = node.getNameNode().getText()\n    if (paramName !== \"side\") {\n      return\n    }\n\n    // Check if this binding element is inside a whitelisted function.\n    const functionDecl = node.getFirstAncestorByKind(\n      SyntaxKind.FunctionDeclaration\n    )\n    const functionName = functionDecl?.getName()\n    if (!functionName || !RTL_SIDE_PROP_COMPONENTS.includes(functionName)) {\n      return\n    }\n\n    const initializer = node.getInitializer()\n    if (!initializer?.isKind(SyntaxKind.StringLiteral)) {\n      return\n    }\n\n    const currentValue = stripQuotes(initializer.getText() ?? \"\")\n    const mappedValue = RTL_SIDE_PROP_MAPPINGS[currentValue]\n    if (mappedValue) {\n      initializer.replaceWithText(`\"${mappedValue}\"`)\n    }\n  })\n}\n","import { Transformer } from \"@/src/utils/transformers\"\nimport { SyntaxKind } from \"ts-morph\"\n\n// Transforms cn-menu-target class based on config.menuColor.\n// If menuColor is \"inverted\", replaces cn-menu-target with \"dark\".\n// Otherwise, removes cn-menu-target entirely.\nexport const transformMenu: Transformer = async ({ sourceFile, config }) => {\n  const menuColor = config.menuColor\n\n  // If menuColor is not set or is \"default\", we remove the placeholder.\n  const replacement = menuColor === \"inverted\" ? \"dark\" : \"\"\n\n  for (const attr of sourceFile.getDescendantsOfKind(SyntaxKind.JsxAttribute)) {\n    const attrName = attr.getNameNode().getText()\n    if (attrName !== \"className\") {\n      continue\n    }\n\n    const initializer = attr.getInitializer()\n    if (!initializer) {\n      continue\n    }\n\n    const text = initializer.getText()\n    if (!text.includes(\"cn-menu-target\")) {\n      continue\n    }\n\n    // Replace cn-menu-target with the replacement value.\n    let newText = text.replace(/cn-menu-target/g, replacement)\n\n    // Clean up extra spaces if we removed the class.\n    if (!replacement) {\n      // Remove double spaces.\n      newText = newText.replace(/\\s{2,}/g, \" \")\n      // Clean up leading/trailing spaces in strings.\n      newText = newText.replace(/\"\\s+/g, '\"')\n      newText = newText.replace(/\\s+\"/g, '\"')\n      // Clean up empty strings in cn() calls.\n      newText = newText.replace(/,\\s*\"\"\\s*,/g, \",\")\n      newText = newText.replace(/\\(\\s*\"\"\\s*,/g, \"(\")\n      newText = newText.replace(/,\\s*\"\"\\s*\\)/g, \")\")\n    }\n\n    attr.setInitializer(newText)\n  }\n\n  return sourceFile\n}\n"]}