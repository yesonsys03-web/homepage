{"version":3,"sources":["../../src/styles/create-style-map.ts","../../src/styles/transform-style-map.ts","../../src/styles/transform.ts","../../src/utils/transformers/transform-render.ts"],"names":["CN_PREFIX","styleMapSchema","z","createStyleMap","input","root","postcss","result","rule","selectors","tailwindClasses","extractTailwindClasses","selector","normalizedSelector","normalizeSelector","selectorParser","selectorsRoot","sel","targetClass","findSubjectClass","className","classes","node","value","classNodes","classNode","ALLOWLIST","isStringLiteralLike","Node","transformStyleMap","sourceFile","styleMap","matchedClasses","applyToCvaCalls","applyToClassNameAttributes","applyToMergePropsCalls","applyStyleToCvaString","stringNode","stringValue","cnClasses","extractCnClasses","unmatchedClasses","cnClass","updated","removeCnClasses","tailwindClassesToApply","mergedClasses","mergeClasses","expression","baseArg","configArg","variantsProp","prop","variantsObj","typeProp","typeObj","variantProp","variantValue","initializer","extractCnClassesFromAttribute","jsxElement","cleanCnClassesFromAttribute","applyClassesToElement","isCnCall","argument","cleaned","removeEmptyArgumentsFromCnCall","str","matches","match","callExpression","args","nonEmptyArgs","arg","argTexts","parent","element","attribute","attr","existing","firstArg","i","argText","argumentTexts","updatedArguments","newClasses","twMerge","call","classNameProp","classNameInitializer","extractCnClassesFromCnCall","cleanCnClassesFromCnCall","applyClassesToCnCall","cnCall","transformStyle","source","transformers","Project","ScriptKind","transformer","transformRender","config","transformations","jsxElements","SyntaxKind","openingElement","renderAttr","childrenText","c","selfClosingElement","tagName","attributes","newRenderValue","parentTagName","otherAttrs","newAttrs","newElementText","info","fullText","newFullText"],"mappings":"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","file":"index.js","sourcesContent":["import postcss from \"postcss\"\nimport selectorParser, {\n  type ClassName,\n  type Selector as SelectorNodeRoot,\n} from \"postcss-selector-parser\"\nimport { z } from \"zod\"\n\nconst CN_PREFIX = \"cn-\"\n\nexport const styleMapSchema = z.record(\n  z.string().startsWith(CN_PREFIX),\n  z.string()\n)\n\nexport type StyleMap = z.infer<typeof styleMapSchema>\n\nexport function createStyleMap(input: string) {\n  const root = postcss.parse(input)\n\n  const result: Record<string, string> = {}\n\n  root.walkRules((rule) => {\n    const selectors = rule.selectors ?? []\n\n    if (selectors.length === 0) {\n      return\n    }\n\n    const tailwindClasses = extractTailwindClasses(rule)\n\n    if (!tailwindClasses) {\n      return\n    }\n\n    for (const selector of selectors) {\n      const normalizedSelector = normalizeSelector(selector)\n\n      selectorParser((selectorsRoot) => {\n        selectorsRoot.each((sel) => {\n          const targetClass = findSubjectClass(sel)\n\n          if (!targetClass) {\n            return\n          }\n\n          const className = targetClass.value\n\n          if (!className.startsWith(CN_PREFIX)) {\n            return\n          }\n\n          result[className] = result[className]\n            ? `${tailwindClasses} ${result[className]}`\n            : tailwindClasses\n        })\n      }).processSync(normalizedSelector)\n    }\n  })\n\n  return styleMapSchema.parse(result)\n}\n\nfunction normalizeSelector(selector: string) {\n  return selector.replace(/\\s*&\\s*/g, \"\").trim()\n}\n\nfunction extractTailwindClasses(rule: postcss.Rule) {\n  const classes: string[] = []\n\n  for (const node of rule.nodes || []) {\n    if (node.type === \"atrule\" && node.name === \"apply\") {\n      const value = node.params.trim()\n      if (value) {\n        classes.push(value)\n      }\n    }\n  }\n\n  if (classes.length === 0) {\n    return null\n  }\n\n  return classes.join(\" \")\n}\n\nfunction findSubjectClass(selector: SelectorNodeRoot) {\n  const classNodes: ClassName[] = []\n\n  selector.walkClasses((classNode) => {\n    if (classNode.value.startsWith(CN_PREFIX)) {\n      classNodes.push(classNode)\n    }\n  })\n\n  if (classNodes.length === 0) {\n    return null\n  }\n\n  return classNodes[classNodes.length - 1]\n}\n","import { TransformerStyle } from \"@/src/styles/transform\"\nimport { twMerge } from \"tailwind-merge\"\nimport {\n  Node,\n  type CallExpression,\n  type NoSubstitutionTemplateLiteral,\n  type SourceFile,\n  type StringLiteral,\n} from \"ts-morph\"\n\nimport { type StyleMap } from \"./create-style-map\"\n\n/**\n * Classes that should never be removed during transformation.\n * These are typically used as CSS selectors or for other purposes\n * that require the class name to remain in the code.\n */\n// TODO: all cn-* classes to be allowedlisted.\nconst ALLOWLIST = new Set([\"cn-menu-target\", \"cn-logical-sides\", \"cn-rtl-flip\"])\n\nfunction isStringLiteralLike(\n  node: Node\n): node is StringLiteral | NoSubstitutionTemplateLiteral {\n  return (\n    Node.isStringLiteral(node) || Node.isNoSubstitutionTemplateLiteral(node)\n  )\n}\n\nexport const transformStyleMap: TransformerStyle<SourceFile> = async ({\n  sourceFile,\n  styleMap,\n}) => {\n  const matchedClasses = new Set<string>()\n\n  applyToCvaCalls(sourceFile, styleMap, matchedClasses)\n  applyToClassNameAttributes(sourceFile, styleMap, matchedClasses)\n  applyToMergePropsCalls(sourceFile, styleMap, matchedClasses)\n\n  return sourceFile\n}\n\nfunction applyStyleToCvaString(\n  stringNode: StringLiteral,\n  styleMap: StyleMap,\n  matchedClasses: Set<string>\n) {\n  const stringValue = stringNode.getLiteralText()\n  const cnClasses = extractCnClasses(stringValue)\n\n  if (cnClasses.length === 0) {\n    return\n  }\n\n  // Process all cn-* classes, not just the first one\n  const unmatchedClasses = cnClasses.filter(\n    (cnClass) => !matchedClasses.has(cnClass)\n  )\n\n  if (unmatchedClasses.length === 0) {\n    // All classes already matched, just clean up non-allowlisted ones\n    const updated = removeCnClasses(stringValue)\n    stringNode.setLiteralValue(updated)\n    return\n  }\n\n  const tailwindClassesToApply = unmatchedClasses\n    .map((cnClass) => styleMap[cnClass])\n    .filter((classes): classes is string => Boolean(classes))\n\n  if (tailwindClassesToApply.length > 0) {\n    const mergedClasses = tailwindClassesToApply.join(\" \")\n    const updated = removeCnClasses(mergeClasses(mergedClasses, stringValue))\n    stringNode.setLiteralValue(updated)\n    unmatchedClasses.forEach((cnClass) => matchedClasses.add(cnClass))\n  } else {\n    // No styles to apply, but still need to clean up non-allowlisted classes\n    const updated = removeCnClasses(stringValue)\n    stringNode.setLiteralValue(updated)\n  }\n}\n\nfunction applyToCvaCalls(\n  sourceFile: SourceFile,\n  styleMap: StyleMap,\n  matchedClasses: Set<string>\n) {\n  sourceFile.forEachDescendant((node) => {\n    if (!Node.isCallExpression(node)) {\n      return\n    }\n\n    const expression = node.getExpression()\n    if (!Node.isIdentifier(expression) || expression.getText() !== \"cva\") {\n      return\n    }\n\n    const baseArg = node.getArguments()[0]\n    if (Node.isStringLiteral(baseArg)) {\n      applyStyleToCvaString(baseArg, styleMap, matchedClasses)\n    }\n\n    const configArg = node.getArguments()[1]\n    if (!configArg || !Node.isObjectLiteralExpression(configArg)) {\n      return\n    }\n\n    const variantsProp = configArg\n      .getProperties()\n      .find(\n        (prop) =>\n          Node.isPropertyAssignment(prop) &&\n          Node.isIdentifier(prop.getNameNode()) &&\n          prop.getNameNode().getText() === \"variants\"\n      )\n\n    if (!variantsProp || !Node.isPropertyAssignment(variantsProp)) {\n      return\n    }\n\n    const variantsObj = variantsProp.getInitializer()\n    if (!variantsObj || !Node.isObjectLiteralExpression(variantsObj)) {\n      return\n    }\n\n    variantsObj.getProperties().forEach((typeProp) => {\n      if (!Node.isPropertyAssignment(typeProp)) {\n        return\n      }\n\n      const typeObj = typeProp.getInitializer()\n      if (!typeObj || !Node.isObjectLiteralExpression(typeObj)) {\n        return\n      }\n\n      typeObj.getProperties().forEach((variantProp) => {\n        if (!Node.isPropertyAssignment(variantProp)) {\n          return\n        }\n\n        const variantValue = variantProp.getInitializer()\n        if (variantValue && Node.isStringLiteral(variantValue)) {\n          applyStyleToCvaString(variantValue, styleMap, matchedClasses)\n        }\n      })\n    })\n  })\n}\n\nfunction applyToClassNameAttributes(\n  sourceFile: SourceFile,\n  styleMap: StyleMap,\n  matchedClasses: Set<string>\n) {\n  sourceFile.forEachDescendant((node) => {\n    if (\n      !Node.isJsxAttribute(node) ||\n      node.getNameNode().getText() !== \"className\"\n    ) {\n      return\n    }\n\n    const initializer = node.getInitializer()\n    if (!initializer) {\n      return\n    }\n\n    const cnClasses = extractCnClassesFromAttribute(initializer)\n\n    if (cnClasses.length === 0) {\n      return\n    }\n\n    const jsxElement = node.getParent()?.getParent()\n    if (\n      !jsxElement ||\n      (!Node.isJsxOpeningElement(jsxElement) &&\n        !Node.isJsxSelfClosingElement(jsxElement))\n    ) {\n      return\n    }\n\n    const unmatchedClasses = cnClasses.filter(\n      (cnClass) => !matchedClasses.has(cnClass)\n    )\n\n    if (unmatchedClasses.length === 0) {\n      // Even if all classes are already matched, we still need to clean them up\n      cleanCnClassesFromAttribute(initializer)\n      return\n    }\n\n    const tailwindClassesToApply = unmatchedClasses\n      .map((cnClass) => styleMap[cnClass])\n      .filter((classes): classes is string => Boolean(classes))\n\n    if (tailwindClassesToApply.length > 0) {\n      const mergedClasses = tailwindClassesToApply.join(\" \")\n      applyClassesToElement(jsxElement, mergedClasses)\n    } else {\n      cleanCnClassesFromAttribute(initializer)\n    }\n  })\n}\n\nfunction extractCnClassesFromAttribute(initializer: Node) {\n  const classes: string[] = []\n\n  if (isStringLiteralLike(initializer)) {\n    return extractCnClasses(initializer.getLiteralText())\n  }\n\n  if (!Node.isJsxExpression(initializer)) {\n    return classes\n  }\n\n  const expression = initializer.getExpression()\n  if (!expression) {\n    return classes\n  }\n\n  if (isStringLiteralLike(expression)) {\n    return extractCnClasses(expression.getLiteralText())\n  }\n\n  if (Node.isCallExpression(expression) && isCnCall(expression)) {\n    for (const argument of expression.getArguments()) {\n      if (isStringLiteralLike(argument)) {\n        classes.push(...extractCnClasses(argument.getLiteralText()))\n      }\n    }\n  }\n\n  return classes\n}\n\nfunction cleanCnClassesFromAttribute(initializer: Node) {\n  if (isStringLiteralLike(initializer)) {\n    const cleaned = removeCnClasses(initializer.getLiteralText())\n    initializer.setLiteralValue(cleaned)\n    return\n  }\n\n  if (!Node.isJsxExpression(initializer)) {\n    return\n  }\n\n  const expression = initializer.getExpression()\n  if (!expression) {\n    return\n  }\n\n  if (isStringLiteralLike(expression)) {\n    const cleaned = removeCnClasses(expression.getLiteralText())\n    expression.setLiteralValue(cleaned)\n    return\n  }\n\n  if (Node.isCallExpression(expression) && isCnCall(expression)) {\n    for (const argument of expression.getArguments()) {\n      if (isStringLiteralLike(argument)) {\n        const cleaned = removeCnClasses(argument.getLiteralText())\n        argument.setLiteralValue(cleaned)\n      }\n    }\n\n    removeEmptyArgumentsFromCnCall(expression)\n  }\n}\n\nfunction extractCnClasses(str: string) {\n  const matches = str.matchAll(/\\bcn-[\\w-]+\\b/g)\n  return Array.from(matches, (match) => match[0])\n}\n\nfunction extractCnClass(str: string) {\n  const classes = extractCnClasses(str)\n  return classes[0] ?? null\n}\n\nfunction removeCnClasses(str: string) {\n  return str\n    .replace(/\\bcn-[\\w-]+\\b/g, (match) => {\n      // Preserve allowlisted classes\n      if (ALLOWLIST.has(match)) {\n        return match\n      }\n      return \"\"\n    })\n    .replace(/\\s+/g, \" \")\n    .trim()\n}\n\nfunction removeEmptyArgumentsFromCnCall(callExpression: CallExpression) {\n  if (!isCnCall(callExpression)) {\n    return\n  }\n\n  const args = callExpression.getArguments()\n  const nonEmptyArgs = args.filter((arg) => {\n    if (isStringLiteralLike(arg)) {\n      const text = arg.getLiteralText().trim()\n      return text !== \"\"\n    }\n    return true\n  })\n\n  if (nonEmptyArgs.length !== args.length) {\n    const argTexts = nonEmptyArgs.map((arg) => arg.getText())\n    const parent = callExpression.getParent()\n    if (parent && Node.isJsxExpression(parent)) {\n      parent.replaceWithText(`{cn(${argTexts.join(\", \")})}`)\n    } else {\n      callExpression.replaceWithText(`cn(${argTexts.join(\", \")})`)\n    }\n  }\n}\n\nfunction applyClassesToElement(element: Node, tailwindClasses: string) {\n  if (\n    !Node.isJsxOpeningElement(element) &&\n    !Node.isJsxSelfClosingElement(element)\n  ) {\n    return\n  }\n\n  const attribute = element\n    .getAttributes()\n    .find(\n      (attr) =>\n        Node.isJsxAttribute(attr) &&\n        attr.getNameNode().getText() === \"className\"\n    )\n\n  if (!attribute || !Node.isJsxAttribute(attribute)) {\n    element.addAttribute({\n      name: \"className\",\n      initializer: `{cn(${JSON.stringify(tailwindClasses)})}`,\n    })\n    return\n  }\n\n  const initializer = attribute.getInitializer()\n\n  if (!initializer) {\n    attribute.setInitializer(`{cn(${JSON.stringify(tailwindClasses)})}`)\n    return\n  }\n\n  if (isStringLiteralLike(initializer)) {\n    const existing = initializer.getLiteralText()\n    const updated = removeCnClasses(mergeClasses(tailwindClasses, existing))\n    initializer.setLiteralValue(updated)\n    return\n  }\n\n  if (!Node.isJsxExpression(initializer)) {\n    return\n  }\n\n  const expression = initializer.getExpression()\n\n  if (!expression) {\n    attribute.setInitializer(`{cn(${JSON.stringify(tailwindClasses)})}`)\n    return\n  }\n\n  if (isStringLiteralLike(expression)) {\n    const existing = expression.getLiteralText()\n    const updated = removeCnClasses(mergeClasses(tailwindClasses, existing))\n    expression.setLiteralValue(updated)\n    return\n  }\n\n  if (Node.isCallExpression(expression) && isCnCall(expression)) {\n    const firstArg = expression.getArguments()[0]\n    if (isStringLiteralLike(firstArg)) {\n      const existing = firstArg.getLiteralText()\n      const updated = removeCnClasses(mergeClasses(tailwindClasses, existing))\n      firstArg.setLiteralValue(updated)\n\n      for (let i = 1; i < expression.getArguments().length; i++) {\n        const arg = expression.getArguments()[i]\n        if (isStringLiteralLike(arg)) {\n          const argText = arg.getLiteralText()\n          const cleaned = removeCnClasses(argText)\n          if (cleaned !== argText) {\n            arg.setLiteralValue(cleaned)\n          }\n        }\n      }\n\n      removeEmptyArgumentsFromCnCall(expression)\n      return\n    }\n\n    const argumentTexts = expression\n      .getArguments()\n      .map((argument) => {\n        if (isStringLiteralLike(argument)) {\n          const cleaned = removeCnClasses(argument.getLiteralText())\n          return cleaned ? JSON.stringify(cleaned) : null\n        }\n        return argument.getText()\n      })\n      .filter((arg): arg is string => arg !== null)\n\n    const updatedArguments = [JSON.stringify(tailwindClasses), ...argumentTexts]\n\n    attribute.setInitializer(`{cn(${updatedArguments.join(\", \")})}`)\n    return\n  }\n\n  attribute.setInitializer(\n    `{cn(${JSON.stringify(tailwindClasses)}, ${expression.getText()})}`\n  )\n}\n\nfunction mergeClasses(newClasses: string, existing: string) {\n  return twMerge(newClasses, existing)\n}\n\nfunction isCnCall(call: CallExpression) {\n  const expression = call.getExpression()\n  return Node.isIdentifier(expression) && expression.getText() === \"cn\"\n}\n\nfunction applyToMergePropsCalls(\n  sourceFile: SourceFile,\n  styleMap: StyleMap,\n  matchedClasses: Set<string>\n) {\n  sourceFile.forEachDescendant((node) => {\n    if (!Node.isCallExpression(node)) {\n      return\n    }\n\n    const expression = node.getExpression()\n    if (\n      !Node.isIdentifier(expression) ||\n      expression.getText() !== \"mergeProps\"\n    ) {\n      return\n    }\n\n    // Look for object literals in mergeProps arguments\n    for (const arg of node.getArguments()) {\n      if (!Node.isObjectLiteralExpression(arg)) {\n        continue\n      }\n\n      // Find className property in the object literal\n      const classNameProp = arg\n        .getProperties()\n        .find(\n          (prop) =>\n            Node.isPropertyAssignment(prop) &&\n            Node.isIdentifier(prop.getNameNode()) &&\n            prop.getNameNode().getText() === \"className\"\n        )\n\n      if (!classNameProp || !Node.isPropertyAssignment(classNameProp)) {\n        continue\n      }\n\n      const classNameInitializer = classNameProp.getInitializer()\n      if (!classNameInitializer) {\n        continue\n      }\n\n      // Handle cn() calls in className\n      if (\n        Node.isCallExpression(classNameInitializer) &&\n        isCnCall(classNameInitializer)\n      ) {\n        const cnClasses = extractCnClassesFromCnCall(classNameInitializer)\n\n        if (cnClasses.length === 0) {\n          continue\n        }\n\n        const unmatchedClasses = cnClasses.filter(\n          (cnClass) => !matchedClasses.has(cnClass)\n        )\n\n        if (unmatchedClasses.length === 0) {\n          // Clean up cn-* classes even if already matched\n          cleanCnClassesFromCnCall(classNameInitializer)\n          continue\n        }\n\n        const tailwindClassesToApply = unmatchedClasses\n          .map((cnClass) => styleMap[cnClass])\n          .filter((classes): classes is string => Boolean(classes))\n\n        if (tailwindClassesToApply.length > 0) {\n          const mergedClasses = tailwindClassesToApply.join(\" \")\n          applyClassesToCnCall(\n            classNameInitializer,\n            mergedClasses,\n            matchedClasses,\n            unmatchedClasses\n          )\n        } else {\n          cleanCnClassesFromCnCall(classNameInitializer)\n        }\n      }\n    }\n  })\n}\n\nfunction extractCnClassesFromCnCall(cnCall: CallExpression): string[] {\n  const classes: string[] = []\n\n  for (const argument of cnCall.getArguments()) {\n    if (isStringLiteralLike(argument)) {\n      classes.push(...extractCnClasses(argument.getLiteralText()))\n    }\n  }\n\n  return classes\n}\n\nfunction cleanCnClassesFromCnCall(cnCall: CallExpression) {\n  for (const argument of cnCall.getArguments()) {\n    if (isStringLiteralLike(argument)) {\n      const cleaned = removeCnClasses(argument.getLiteralText())\n      argument.setLiteralValue(cleaned)\n    }\n  }\n\n  removeEmptyArgumentsFromCnCall(cnCall)\n}\n\nfunction applyClassesToCnCall(\n  cnCall: CallExpression,\n  tailwindClasses: string,\n  matchedClasses: Set<string>,\n  unmatchedClasses: string[]\n) {\n  const firstArg = cnCall.getArguments()[0]\n\n  if (isStringLiteralLike(firstArg)) {\n    const existing = firstArg.getLiteralText()\n    const updated = removeCnClasses(mergeClasses(tailwindClasses, existing))\n    firstArg.setLiteralValue(updated)\n\n    // Mark classes as matched\n    unmatchedClasses.forEach((cnClass) => matchedClasses.add(cnClass))\n\n    // Clean up cn-* classes from remaining arguments\n    for (let i = 1; i < cnCall.getArguments().length; i++) {\n      const arg = cnCall.getArguments()[i]\n      if (isStringLiteralLike(arg)) {\n        const argText = arg.getLiteralText()\n        const cleaned = removeCnClasses(argText)\n        if (cleaned !== argText) {\n          arg.setLiteralValue(cleaned)\n        }\n      }\n    }\n\n    removeEmptyArgumentsFromCnCall(cnCall)\n    return\n  }\n\n  // If first arg is not a string literal, prepend tailwind classes\n  const argumentTexts = cnCall\n    .getArguments()\n    .map((argument) => {\n      if (isStringLiteralLike(argument)) {\n        const cleaned = removeCnClasses(argument.getLiteralText())\n        return cleaned ? JSON.stringify(cleaned) : null\n      }\n      return argument.getText()\n    })\n    .filter((arg): arg is string => arg !== null)\n\n  const updatedArguments = [JSON.stringify(tailwindClasses), ...argumentTexts]\n\n  // Mark classes as matched\n  unmatchedClasses.forEach((cnClass) => matchedClasses.add(cnClass))\n\n  const parent = cnCall.getParent()\n  if (parent) {\n    cnCall.replaceWithText(`cn(${updatedArguments.join(\", \")})`)\n  }\n}\n","import { Project, ScriptKind, type SourceFile } from \"ts-morph\"\n\nimport { type StyleMap } from \"./create-style-map\"\nimport { transformStyleMap } from \"./transform-style-map\"\n\nexport type TransformerStyle<Output = SourceFile> = (opts: {\n  sourceFile: SourceFile\n  styleMap: StyleMap\n}) => Promise<Output>\n\nexport async function transformStyle(\n  source: string,\n  {\n    styleMap,\n    transformers = [transformStyleMap],\n  }: {\n    styleMap: StyleMap\n    transformers?: TransformerStyle<SourceFile>[]\n  }\n) {\n  const project = new Project({\n    useInMemoryFileSystem: true,\n  })\n\n  const sourceFile = project.createSourceFile(\"component.tsx\", source, {\n    scriptKind: ScriptKind.TSX,\n    overwrite: true,\n  })\n\n  for (const transformer of transformers) {\n    await transformer({ sourceFile, styleMap })\n  }\n\n  return sourceFile.getText()\n}\n","import { Transformer } from \"@/src/utils/transformers\"\nimport { SyntaxKind } from \"ts-morph\"\n\ninterface TransformInfo {\n  elementStart: number\n  elementEnd: number\n  newText: string\n}\n\nexport const transformRender: Transformer = async ({ sourceFile, config }) => {\n  // Only run for base- styles.\n  if (!config.style?.startsWith(\"base-\")) {\n    return sourceFile\n  }\n\n  // Collect all transformations first, then apply them in reverse order.\n  // This prevents issues with invalidated nodes when modifying the tree.\n  const transformations: TransformInfo[] = []\n\n  // Find all JSX elements with render attribute.\n  const jsxElements = sourceFile.getDescendantsOfKind(SyntaxKind.JsxElement)\n\n  for (const jsxElement of jsxElements) {\n    const openingElement = jsxElement.getOpeningElement()\n    const renderAttr = openingElement.getAttribute(\"render\")\n\n    if (!renderAttr) {\n      continue\n    }\n\n    // Get the children of the parent element.\n    const children = jsxElement.getJsxChildren()\n    const childrenText = children\n      .map((c) => c.getText())\n      .join(\"\")\n      .trim()\n\n    // If there are no children, nothing to transform.\n    if (!childrenText) {\n      continue\n    }\n\n    // Get the render attribute value.\n    if (renderAttr.getKind() !== SyntaxKind.JsxAttribute) {\n      continue\n    }\n\n    const jsxAttr = renderAttr.asKindOrThrow(SyntaxKind.JsxAttribute)\n    const initializer = jsxAttr.getInitializer()\n\n    if (!initializer) {\n      continue\n    }\n\n    // The render value should be a JSX expression like {<Button />}.\n    if (initializer.getKind() !== SyntaxKind.JsxExpression) {\n      continue\n    }\n\n    const jsxExpression = initializer.asKindOrThrow(SyntaxKind.JsxExpression)\n    const expression = jsxExpression.getExpression()\n\n    if (!expression) {\n      continue\n    }\n\n    // Check if the expression is a self-closing JSX element.\n    if (expression.getKind() !== SyntaxKind.JsxSelfClosingElement) {\n      // If it's already a full JSX element with children, skip it.\n      continue\n    }\n\n    const selfClosingElement = expression.asKindOrThrow(\n      SyntaxKind.JsxSelfClosingElement\n    )\n    const tagName = selfClosingElement.getTagNameNode().getText()\n    const attributes = selfClosingElement\n      .getAttributes()\n      .map((attr) => attr.getText())\n      .join(\" \")\n\n    // Build new render prop value with children moved inside.\n    const newRenderValue = attributes\n      ? `{<${tagName} ${attributes}>${childrenText}</${tagName}>}`\n      : `{<${tagName}>${childrenText}</${tagName}>}`\n\n    // Get the parent tag name and other attributes.\n    const parentTagName = openingElement.getTagNameNode().getText()\n    const otherAttrs = openingElement\n      .getAttributes()\n      .filter((attr) => {\n        if (attr.getKind() === SyntaxKind.JsxAttribute) {\n          const attrName = attr\n            .asKindOrThrow(SyntaxKind.JsxAttribute)\n            .getNameNode()\n            .getText()\n          return attrName !== \"render\"\n        }\n        return true\n      })\n      .map((attr) => attr.getText())\n      .join(\" \")\n\n    // Build new element text as self-closing since children are now in render.\n    const newAttrs = otherAttrs\n      ? `${otherAttrs} render=${newRenderValue}`\n      : `render=${newRenderValue}`\n\n    const newElementText = `<${parentTagName} ${newAttrs} />`\n\n    transformations.push({\n      elementStart: jsxElement.getStart(),\n      elementEnd: jsxElement.getEnd(),\n      newText: newElementText,\n    })\n  }\n\n  // Apply transformations in reverse order to preserve positions.\n  for (const info of transformations.reverse()) {\n    const fullText = sourceFile.getFullText()\n    const newFullText =\n      fullText.substring(0, info.elementStart) +\n      info.newText +\n      fullText.substring(info.elementEnd)\n    sourceFile.replaceWithText(newFullText)\n  }\n\n  return sourceFile\n}\n"]}